**Basic SW**
`cargo install itm
```
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- --default-toolchain none -y
rustup toolchain install nightly --allow-downgrade --profile minimal --component clippy
```

`rustup component add llvm-tools-preview
`sudo apt-get install \`
  `gdb-multiarch \`
  `minicom \`
  `openocd`

**Set udev rules so that the device can be programmed by any user**

Find device id and vendor id:
`lsusb | grep ST-LINK
You should get sth like:
`$ lsusb | grep ST-LINK
Bus 003 Device 003: ID 0483:374b STMicroelectronics ST-LINK/V2.1
0483 is the device id, 374b is vendor id.

Create the file:
/etc/udev/rules.d/99-openocd.rules

And put:
`# STM32F3DISCOVERY - ST-LINK/V2.1
`ATTRS{idVendor}=="0483", ATTRS{idProduct}=="374b", MODE:="0666"
`

Reload rules:
`sudo udevadm control --reload-rules

**Create project**
If you don't have cargo generate:
`cargo install cargo-generate`
`cargo generate --git https://github.com/burrbull/stm32-template/`
It will ask for your exact microcontroller info
```
cargo generate --git https://github.com/burrbull/stm32-template/
🤷   Project Name: test_embedded
⚠️   Renaming project called `test_embedded` to `test-embedded`...
🔧   Destination: /home/synics-dev/Documents/Synics/embedded_rust_test/test-embedded ...
🔧   project-name: test-embedded ...
🔧   Generating template ...
✔ 🤷   What HAL version to use? · last-release
✔ 🤷   Is it RTIC-based application? · true
✔ 🤷   Will this program use defmt logger? · false
🤷   What microcontroller name? [default: stm32f411ceu6]: stm32l452ret6u
453:1 | "Microcontroller family: stm32l452"
472:1 | "Linker memory blocks:\n  FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 512K\n  RAM (rwx) : ORIGIN = 0x20000000, LENGTH = 160K"
🔧   Moving generated files into: `/home/synics-dev/Documents/Synics/embedded_rust_test/test-embedded`...
🔧   Initializing a fresh Git repository
✨   Done! New project created /home/synics-dev/Documents/Synics/embedded_rust_test/test-embedded

```

In my case, for the STM32L452RET6U, it generated the memory.x file and the config file automagically. The memory.x file says where the flash and the ram are in the memory mapping. The config file is inside .cargo and it tells the system which target architecture you have:


**Download the target**
```
rustup target add thumbv7em-none-eabihf
```
**.cargo/config.toml**
This is the cargo autogenerated file. Pay attention to the target, that will change depending on the processor.
`[target.'cfg(all(target_arch = "arm", target_os = "none"))']`
`runner = "probe-rs run --chip STM32L452RETx"`

`rustflags = [`
  # `LLD (shipped with the Rust toolchain) is used as the default linker`
  `"-C", "link-arg=-Tlink.x",`
  # `"-C", "link-arg=-Tdefmt.x",`
  # `"-C", "link-arg=-Tstlog.x",`

  # `if you run into problems with LLD switch to the GNU linker by commenting out`
  # `this line`
  # `"-C", "linker=arm-none-eabi-ld",`

  # `if you need to link to pre-compiled C libraries provided by a C toolchain`
  # `use GCC as the linker by commenting out both lines above and then`
  # `uncommenting the three lines below`
  # `"-C", "linker=arm-none-eabi-gcc",`
  # `"-C", "link-arg=-Wl,-Tlink.x",`
  # `"-C", "link-arg=-nostartfiles",`
`]`

`[build]`
`target = "thumbv7em-none-eabihf"`

`[env]`
#`DEFMT_LOG = "info"`

### Important - Replace the code automatically given by this
```
//! Blinks an LED

#![no_std]
#![no_main]

extern crate cortex_m;
#[macro_use]
extern crate cortex_m_rt as rt;
extern crate cortex_m_semihosting as sh;
extern crate panic_semihosting;
extern crate stm32l4xx_hal as hal;
// #[macro_use(block)]
// extern crate nb;

use crate::hal::delay::Delay;
use crate::hal::prelude::*;
use crate::rt::entry;
use crate::rt::ExceptionFrame;

#[entry]
fn main() -> ! {

    let cp = cortex_m::Peripherals::take().unwrap();
    let dp = hal::stm32::Peripherals::take().unwrap();

    let mut flash = dp.FLASH.constrain(); // .constrain();
    let mut rcc = dp.RCC.constrain();
    let mut pwr = dp.PWR.constrain(&mut rcc.apb1r1);

    // Try a different clock configuration, if it fails, uncomment one and comment the other
    //let clocks = rcc.cfgr.hclk(8.MHz()).freeze(&mut flash.acr, &mut pwr);
    let clocks = rcc.cfgr
         .sysclk(64.MHz())
         .pclk1(32.MHz()).freeze(&mut flash.acr, &mut pwr);

    // let mut gpioc = dp.GPIOC.split(&mut rcc.ahb2);
    // let mut led = gpioc.pc13.into_push_pull_output(&mut gpioc.afrh);

    let mut gpioa = dp.GPIOA.split(&mut rcc.ahb2);
    let mut led = gpioa
        .pa5
        .into_push_pull_output(&mut gpioa.moder, &mut gpioa.otyper);

    let mut timer = Delay::new(cp.SYST, clocks);
    loop {
        // block!(timer.wait()).unwrap();
        timer.delay_ms(1000_u32);
        led.set_high();
        // block!(timer.wait()).unwrap();
        timer.delay_ms(1000_u32);
        led.set_low();
    }
}

#[exception]
unsafe fn HardFault(ef: &ExceptionFrame) -> ! {
    panic!("{:#?}", ef);
}
```
**Build**

`cargo build
This should generate this:
```
target/thumbv7em-none-eabihf/debug/<project-name>
```

**Install flasher**
```cargo install cargo-flasher```
**Flash it**
```
cargo flash --release --chip STM32L452RETx
```

**Debug it**
*Prepare OpenOCD to connect to the target*
```
openocd -f /usr/share/openocd/scripts/interface/stlink-v2.cfg -f /usr/share/openocd/scripts/target/stm32l4x.cfg
```

And then:
`gdb-multiarch -q -ex "target remote :3333" target/thumbv7em-none-eabihf/debug/stmtest2`
